1. 系统的整体框架
1.1 使用系统
为完成学生游学系统，本系统采用了B/S框架设计，后端采用django实现，以便于处理高并发的http请求。前端使用vue+vite，以达到良好的演示画面和稳定的运行效果。
1.2 模块设计
游学系统大体分为前端页面和后端页面。
1.2.1 后端模块设计
后端分为：推荐、日记、搜索、寻路和认证五个模块。
- 认证模块
  - 用户登录API
  - 创建用户API
  - 用户注销API
  - 更新用户信息API
- 推荐模块
  - 核心推荐算法
  - 景点推荐API
  - 日记推荐API
- 寻路模块
  - 核心寻路算法
  - 单点寻路API
  - 多点寻路API
  - 获取路线显示API
- 日记模块
  - 创建新日记API
    - 日记数据库映射
  - 获取所有日记API
  - 删除日记API
  - 更新日记API
  - 评分日记API
    - 用户评分数据映射
- 搜索模块
  - 景点搜索API
    - 景点数据库映射
    - 景点搜索历史数据映射
  - 日记搜索API
  - 设施搜索API

1.2.1 前端页面设计
为了便于用户使用，前端页面总体上分为三个模块：游学推荐、日记推荐和个人页面，他们会显示在下方的导航栏。
- 游学推荐（主页）
游学推荐页面作为主页，将会动态显示为您推荐的目的地，点击具体的目的地将会跳转到对应的寻路界面
  - 寻路页面
    - 单目的地和途径多点目的地的寻路规划
    - 全图显示
    - 导航内容展示
  - 搜索界面
    - 景点搜索
    - 设施搜索
    - 日记搜索
  - AIGC界面
    - 支持上传图片并由AI生成视频，视频将存储在个人账户中
- 日记推荐
  日记推荐界面将自动显示所有推荐到日记
  - 查看全部日记界面
    - 此界面允许查看所有及评分
  - 创建日记界面
    - 此界面允许创建一个新的日记
  - 日记评分按钮
    - 允许用户评分并显示评分
- 个人界面
  - 个人信息显示及修改
  - 个人日记信息显示及修改

2. 实现功能
2.1 登录与注册
在首次访问网站时可能需要先注册到游学系统，这之后需要使用用户名和密码进行登录。每一次登录，前端程序都会存储你的登录令牌，令牌有效时间为一天。
[图片]
[图片]

[图片]
2.2 推荐功能
2.2.1 游学景点推荐功能
登陆成功后进入游学系统首页，你将能看见首页根据您的个人喜好，以及评分和热度专门为你推荐的景点和目的地

[图片]

您也可以在首页上方的小按钮浏览全部景
[图片]

2.2.2 日记推荐功能
通过下方导航栏进入日记界面，你将会看见为您独家提供的日记推荐系统
[图片]

2.3 搜索功能
2.3.1 景点搜索功能
点按推荐系统首页搜索按钮，即可进入到搜索功能中，在这里，你可以搜索所有景点名称
[图片]
右侧的筛选按钮能够帮助您更快的获得您想要的结果，景点搜索支持过滤评分和人气，并且能够按照评分和人气进行排序
[图片]

2.3.2 设施搜索以及范围搜索
在进入景点之后，景点的内部设施同样提供了搜索功能，你可以很方便地直接使用名称匹配出搜索结果
[图片]
设施搜索同样支持一些筛选选项。在确定您的位置之后，您可以选择筛选附近的设施类型，以及特定范围内的所有设施
[图片]
2.3.3 游学日记搜索
日记搜索同样是一个强大的功能，他支持你使用标题、内容和具体地点搜索，当然，我们还支持通过日期范围和用户的ID筛选结果
[图片]

2.4 路线规划功能
2.4.1 选择设施进行路径规划与显示
选择想要出发去往游学的目的地之后，你就能够碰见精心为你准备的路线规划模块。景区之内，你可以自由选择你的起点和重点，然后选择游览策略，这样之后，系统会为您根据策略显示最佳的游览路径
[图片]
[图片]
我们还为您贴心的展示了景区内的全部地图，在为您完成路线规划后，具体的路线也会实时显示出来，帮助您更好地到达目的地
[图片]
[图片]

2.4.2 途径多点的路径规划
当然，简单的单目的地路径规划可能会让您错过精彩的景区，我们为您提供了最多200个途径地点的路径规划，以便您个性化自己的游览路径
[图片]
所有的游览路径和具体的游览路线都会正常显示出来，这一点你不用担心
[图片]
[图片]

2.5 游学日记管理
2.5.1 创建日记
游学怎能没有游学日记呢？在您的游学过程中，你可以随时创建你的游学日记
[图片]
我们甚至为你准备了方便的查找框，能够让你快速锁定你的位置
[图片]

2.5.2 更新或删除日记
日记的更新和删除也非常方便。你的日记最终都会显示在个人主页中。你可以自由的更新或者删除他们。
[图片]
[图片]
2.5.3 浏览全部日记
从系统创建以来的所有日记都会显示在这里
[图片]
2.5.4 日记评分系统

我们拥有一个完善的评分系统，你的每一次评分都会影响日记为他人的展示度。

[图片]
你可以选择喜欢或不喜欢一篇日记，系统会自动记录你对于每一篇日记的评价，
[图片]
[图片]
2.6 AIGC视频生成
如今是AI时代，系统中怎能不支持AI生成功能呢？我们为系统集成了由图片到视频的转换功能，你可以在这个页面查看您生成的所有视频
[图片]
点击右下角的按钮，传入一个你喜欢的图片，然后等待即可
[图片]
[图片]
你的视频会在生成完成后自动存储到您私人的空间中。你可以自由的播放或者转载这些生成好的视频
[图片]
3. 使用到的算法及其分析
3.1 推荐算法
我们实现了一个基于文本内容的推荐算法，具体来说，它通过计算景点描述之间的余弦相似度来推荐相似的景点。
3.1.1 算法思路
1. 文本表示：
  - 首先，通过获取所有景点的描述文本，将这些文本信息转化为机器学习算法能够处理的形式。使用 TF-IDF（Term Frequency-Inverse Document Frequency）方法将文本转换为特征向量。TF-IDF 通过衡量词语在文档中的频率和它在整个文档集合中的反向频率来表示文本特征。
2. 计算相似度：
  - 使用余弦相似度（Cosine Similarity）来衡量景点描述之间的相似度。余弦相似度通过计算两个向量的夹角余弦值来评估它们的相似性，值越接近1表示越相似。
3. 推荐景点：
  - 找出与指定景点描述最相似的其他景点。先找到目标景点在所有景点中的位置，然后计算该景点与所有其他景点的相似度得分，并排序，最后推荐相似度最高的几个景点（排除自身）。
3.1.2 采用理由
1. 基于内容：
  - 该算法仅依赖于景点的描述文本进行推荐，不需要用户的历史行为数据或评分数据，因此能够解决冷启动问题，即在没有用户交互数据的情况下也能提供有效的推荐。
2. 实现简单：
  - 使用了现有的机器学习库（如 sklearn）中的工具，算法实现相对简单，不需要复杂的模型训练和参数调优。
3. 计算高效：
  - TF-IDF 转换和余弦相似度计算的时间复杂度较低，能够快速计算出推荐结果，适合实时推荐系统。
4. 可解释性强：
  - 由于推荐结果直接基于景点描述文本的相似性，推荐的理由容易理解和解释，可以通过查看推荐景点的描述来验证推荐的合理性。
5. 扩展性好：
  - TF-IDF 和余弦相似度的计算可以很容易地扩展到大规模文本数据集，适合处理大量景点描述的情况。
6. 无依赖性：
  - 不依赖于外部数据或特定的用户行为模式，能够在任何时候进行景点推荐，只要有景点描述文本即可。
3.1.3 应用场景
这种基于内容的推荐算法特别适用于旅游景点推荐、文章推荐、电影推荐等任何依赖于文本描述的推荐系统中。在这些场景中，用户可能没有大量的历史行为数据，而内容本身的相似性可以提供有效的推荐。

3.2 Top-K不完全排序
使用大顶堆（最大堆）进行不完全排序的算法，尤其是用于找出前 kkk 个最大元素，通常称为 "Top-K 问题"。
在介绍算法之前，首先介绍堆的概念：
堆（Heap）是一种特殊的完全二叉树，分为大顶堆（Max-Heap）和小顶堆（Min-Heap）。堆常用于实现优先队列、快速查找最大/最小元素等操作。
3.2.1 堆的基本概念
1. 大顶堆（Max-Heap）：
  - 每个节点的值都大于或等于其子节点的值。
  - 堆顶（根节点）的值是整个堆中的最大值。
2. 小顶堆（Min-Heap）：
  - 每个节点的值都小于或等于其子节点的值。
  - 堆顶（根节点）的值是整个堆中的最小值。
3.2.2 堆的操作
堆支持以下基本操作：
1. 插入（Insert）：
  - 将新元素添加到堆的末尾，然后向上调整以维护堆的性质。
  - 时间复杂度为 O(log⁡n)
2. 删除（Delete）：
  - 删除堆顶元素，将堆的最后一个元素移到堆顶，然后向下调整以维护堆的性质。
  - 时间复杂度为 O(log⁡n)
3. 构建堆（Heapify）：
  - 将一个无序数组调整为堆的结构。
  - 时间复杂度为 O(n)
3.2.3 堆排序的原理
堆排序（Heap Sort）利用堆的特性进行排序，主要步骤如下：
1. 构建大顶堆：
  - 将待排序数组构建成一个大顶堆。构建堆的过程从最后一个非叶子节点开始，自下而上调整每个节点。
  - 时间复杂度为 O(n
2. 排序：
  - 依次将堆顶元素（最大值）与堆的最后一个元素交换，然后将堆的大小减一，并重新调整堆以维护大顶堆性质。
  - 这一过程重复 n−1次，每次调整堆的时间复杂度为 O(log⁡n)，因此排序过程的时间复杂度为 O(nlog⁡n)
3.2.4 算法原理
1. 大顶堆的基本概念：
  - 大顶堆是一种完全二叉树，其中每个节点的值都大于或等于其子节点的值。因此，堆顶（根节点）的值是整个堆中的最大值。
2. 不完全排序（Top-K 问题）：
  - 不完全排序并不要求将整个列表进行排序，只需要找到前 kkk 个最大元素即可。
  - 使用大顶堆可以高效地解决这个问题，因为在大顶堆中插入和删除操作的时间复杂度为 O(log⁡k)
3.2.5 具体步骤
假设我们有一个包含 nnn 个元素的列表，需要找到其中前 kkk 个最大元素：
1. 构建大顶堆：
  - 首先，构建一个大小为 k 的最小堆（Python 的 heapq 库默认是最小堆，所以可以通过插入负值来模拟大顶堆）。
  - 将前 k 个元素插入到堆中。
2. 维护堆：
  - 对于列表中的剩余元素，从第 k+1 个元素开始，逐个与堆顶元素进行比较。
  - 如果当前元素大于堆顶元素，则将堆顶元素移除，并将当前元素插入堆中。这样，堆中始终保持前 k个最大元素。
3. 堆排序：
  - 最后，堆中的元素就是前 k 个最大元素，可以通过堆排序将它们按从大到小的顺序输出。
3.3 最短路径
3.3.1 Dijkstra 算法思路

Dijkstra 算法是用于计算加权图中单源最短路径的一种经典算法。其基本思想是通过贪心策略，不断选择距离起点最近的未处理节点进行扩展，直到找到从起点到所有其他节点的最短路径。具体步骤如下：

1. 初始化：
  - 创建一个距离字典 distances，初始化所有节点的距离为无穷大 (infinity)，起点的距离为0。
  - 创建一个前驱节点字典 predecessors，用于记录每个节点在最短路径中的前驱节点。
  - 创建一个优先队列 priority_queue，初始包含起点，优先级为0（起点的距离）。

2. 主循环：
  - 每次从优先队列中弹出当前距离最小的节点 current_vertex 及其距离 current_distance。
  - 如果 current_vertex 是终点，算法终止。
  - 遍历 current_vertex 的所有邻居节点，计算通过 current_vertex 到达邻居节点的距离 distance。
  - 如果找到更短的路径，则更新邻居节点的最短距离和前驱节点，并将邻居节点及其新的距离加入优先队列。

3. 路径回溯：
  - 从终点开始，通过前驱节点字典 predecessors 回溯路径，直到回到起点，构造出最短路径。
  - 计算路径的总距离和总时间（假设图的边权重包含 distance 和 time）。

3.3.2 性能分析
1. 时间复杂度：
  - 使用优先队列（最小堆）实现的 Dijkstra 算法，其时间复杂度为 \(O((V + E) \log V)\)，其中 \(V\) 是图中的节点数，\(E\) 是图中的边数。
  - 在每次操作中，从优先队列中弹出最小元素和插入新元素的操作均为 \(O(\log V)\)。
  - 对于每条边的松弛操作（即更新邻居节点的距离），操作次数为 \(O(E)\)。

2. 空间复杂度：
  - 主要由存储图的结构、距离字典和前驱节点字典等决定，空间复杂度为 \(O(V + E)\)。

3.3.3 采用算法的理由
1. 适用性强：
  - Dijkstra 算法适用于所有边权非负的加权图，广泛应用于路由、地图导航、网络优化等领域。
2. 准确性：
  - 通过贪心策略，Dijkstra 算法能够保证找到从起点到每个节点的最短路径。
3. 高效性：
  - 结合优先队列（最小堆），算法能够高效地处理大规模图结构，尤其在稀疏图中表现良好。
4. 可扩展性：
  - 算法可以扩展支持不同类型的边权重（如距离、时间等），只需在计算邻居节点距离时进行相应调整。
5. 实现简便：
  - 算法实现相对简单，易于理解和编码，对于初学者和工程应用都非常友好。
Dijkstra 算法的优越性在于其在解决最短路径问题上的普适性和高效性，特别适用于大规模网络的路径优化和导航应用。
3.4 途径多点的最短路径
3.4.1 算法思路
途径多点的最短路径问题（Multi-Point Shortest Path Problem）可以视为多个单源最短路径问题的组合。在这种情况下，我们使用 Dijkstra 算法来计算每两个相邻点之间的最短路径，并将这些路径连接起来。该方法不能完全解决旅行商问题（TSP），但它适用于在给定顺序的多个点之间寻找最短路径。具体步骤如下：
1. 初始化：
  - 如果输入的点列表 points 为空，则返回空路径和零距离、时间。
  - 初始化总路径、总距离和总时间。
2. 两点间最短路径：
  - 对于点列表中的每一对相邻点，使用 Dijkstra 算法计算它们之间的最短路径。
  - 累积每段路径的距离和时间。
  - 将每段路径合并到总路径中，避免重复包含路径的起点。
3. 返回结果：
  - 返回总路径、总距离和总时间。
3.4.2 性能分析
  1. 时间复杂度：
    - 该算法的时间复杂度主要由 Dijkstra 算法的复杂度决定。对于每一对相邻点调用一次 Dijkstra 算法，时间复杂度为 O((V+E)log⁡V)，其中 V 是图中的节点数，E 是图中的边数。
    - 假设有 nnn 个点，则总时间复杂度为 O(n⋅(V+E)log⁡V)
  2. 空间复杂度：
    - 主要由存储图的结构、距离字典和前驱节点字典等决定，空间复杂度为 O(V+E)
3.4.3 采用理由
1. 简单易实现：
  - 该算法通过多次调用 Dijkstra 算法实现，代码简单且容易理解。
2. 适用范围广：
  - 适用于所有边权非负的加权图，可以处理各种图结构，只需输入点列表即可找到它们之间的最短路径。
3. 高效性：
  - 对于每一对相邻点，使用 Dijkstra 算法计算最短路径，能高效地找到路径。

3.5 哈夫曼编码
3.5.1 算法步骤
哈夫曼编码是一种无损数据压缩算法，通过对字符进行变长编码来实现压缩。其核心思想是用较短的编码表示频率较高的字符，用较长的编码表示频率较低的字符，从而减少总体编码长度。
算法步骤

1. 计算字符频率：
  - 遍历文本，计算每个字符出现的频率，并存储在一个字典中。

2. 构建哈夫曼树：
  - 为每个字符创建一个叶节点，并将其频率作为权值。
  - 使用优先队列（最小堆）存储所有节点，频率最低的节点具有最高优先级。
  - 反复从优先队列中取出频率最低的两个节点，合并它们，创建一个新节点，其频率为两个子节点频率之和。新节点的左子节点为较小频率的节点，右子节点为较大频率的节点。
  - 将新节点重新插入优先队列。
  - 重复上述过程，直到优先队列中只剩下一个节点，该节点为哈夫曼树的根节点。

3. 生成哈夫曼编码：
  - 从哈夫曼树的根节点开始，遍历树，为每个叶节点分配一个编码。
  - 左子节点分配'0'，右子节点分配'1'。通过递归遍历树，生成每个字符的哈夫曼编码。

4. 压缩文本：
  - 用生成的哈夫曼编码替换文本中的每个字符，形成编码后的二进制字符串。
  - 为了便于存储和传输，将二进制字符串分割为字节，并转换为字节数组。

5. 解压缩文本：
  - 将字节数组转换回二进制字符串。
  - 根据哈夫曼编码表，将二进制字符串解码为原始文本。

3.5.2 性能分析

1. 时间复杂度：
  - 计算字符频率： \( O(n) \)（其中 \( n \) 是文本长度）。
  - 构建哈夫曼树： \( O(d \log d) \)（其中 \( d \) 是不同字符的数量）。
  - 生成哈夫曼编码： \( O(d) \)。
  - 压缩文本： \( O(n) \)。
  - 总时间复杂度： \( O(n + d \log d) \)。

2. 空间复杂度：
  - 频率字典： \( O(d) \)。
  - 哈夫曼树： \( O(d) \)。
  - 哈夫曼编码表： \( O(d) \)。
  - 压缩后的字节数组： 依赖于压缩率。

3. 压缩率分析：
  - 哈夫曼编码的压缩率取决于字符频率分布。如果某些字符频率很高，使用哈夫曼编码可以显著减少编码长度。
  - 理论上的压缩率可以通过计算熵来估计。熵越高，压缩率越低。

3.5.3 采用理由
1. 高效性：
  - 哈夫曼编码在处理数据压缩时效率高，能够快速构建编码树和生成编码。
2. 无损压缩：
  - 哈夫曼编码是一种无损压缩算法，能够保证解压后的数据与原始数据完全一致。
3. 自适应性：
  - 哈夫曼编码根据字符频率动态分配编码，能够自适应不同的数据分布，实现高效压缩。
4. 简单实现：
  - 算法实现相对简单，易于理解和编码，适合各种编程语言和应用场景。

4. 大模型参与过程
我们团队的三人实现均没有接触过网页开发，可以说是小白三只，对B/S开发过程一窍不通，但是，在大模型的帮助下，我们最终一步一步完成了整体的课程设计。

4.1 大模型参与过程
4.1.1 项目框架选择
在项目初期，我们需要选择合适的项目框架。由于对前端和后端开发都不熟悉，我们决定使用大模型的建议来选择框架。大模型推荐我们使用 Vue.js 作为前端框架，因为它易于上手且有丰富的社区支持。同时，推荐使用 django 作为后端框架，因为它轻量且容易集成。我们还学习了如何配置和安装这些框架，并了解了它们的基本结构。


4.1.2 整体框架搭建
在设计阶段，我们向大模型咨询了项目的整体架构和功能需求。大模型帮助我们梳理了用户需求，并将其转化为具体的功能模块和页面设计。同时，明确了数据库设计和前端页面布局。
[图片]
在完成项目设计后，我们开始搭建项目的整体框架。根据大模型提供的教程和代码示例，我们成功地创建了 Vue.js 前端项目和 django后端项目。我们学习了如何设置项目的路由、配置数据库连接以及实现基础的前后端交互。



4.1.3 前端细节实现
在前端开发过程中，大模型帮助我们解决了很多问题。从如何创建和管理组件，到实现页面的动态效果和表单验证，大模型提供了详细的代码示例和解释。我们逐步实现了项目的主要页面，包括用户登录、注册、信息展示和数据输入等。
4.1.4 后端细节实现
后端开发部分，大模型指导我们实现了数据库操作、API 接口和业务逻辑处理。我们学习了如何使用 MySQL 进行数据库操作，如何编写 RESTful API 以及如何处理用户请求和返回数据。大模型还帮助我们实现了用户身份验证和权限管理，确保项目的安全性。
本项目几乎所有代码都由大模型生成并提供.
[图片]
[图片]


4.1.5 前后端链接与完善
在前后端联调阶段，我们遇到了许多问题，例如跨域请求、数据格式转换和错误处理。大模型帮助我们分析并解决了这些问题，并提供了优化建议。通过一步步调试和完善，我们成功地实现了前后端的无缝链接。当然，大模型薄弱的地方在于修理bug，在这个阶段涌现出大量的bug不得不由人工或google搞定
[图片]
4.1.6 美化前端
在项目的最后阶段，我们对前端页面进行了美化。按照自己的想法结合现有的前端代码，使用大模型快速达成想要达到的视觉效果
[图片]
4.2 使用心得与体会
在参与本次数据结构课程设计的过程中，我们深度使用并体验了大模型，对于大模型在开发中的帮助程度有了充分的认识。以下是我们的心得与体会：
4.2.1 使用者水平决定效果
- 大模型的使用效果与使用者的水平息息相关。熟练的开发者能够更好地引导大模型，提出具体且有效的问题，获取高质量的答案。
- 对于复杂的编程问题，如高端的 C++ 模板元编程，大模型能够提供令人惊叹的解决方案。然而，对于一些过时的方法或技术，大模型可能也会提供。
- 通过实际使用，我们认识到需要具备基本的判断能力，能够分辨大模型提供的方案是否符合当前的最佳实践。

4.2.2 保持自主思考
- 解决问题的思路和框架至关重要，这些往往不属于任何特定的编程语言，而是逻辑和策略的体现。
- 面对具体问题，如果没有业界公认的最优解，开发者需要提供大致的解决思路，帮助大模型理解问题背景和要求。
- 大模型在提供具体实现细节上非常强大，但在构建宏观的解决方案上，仍需依赖开发者的智慧和判断。

4.2.3 使用大模型解决 bug 的体验：
- 使用大模型解决 bug 有时是一个痛苦的过程，因为修复 bug 本身就是一个复杂且耗时的工作。
- 大模型能够帮助我们定位问题并提供可能的解决方案，但在某些情况下，我们发现直接通过搜索引擎（如 Google）查找资料和社区讨论更为高效。
- 在修复 bug 时，适当结合大模型与其他资源，可以提高问题解决的效率和准确性。


附件
1. 分工：
张泽睿
2022211397
- 负责项目整体规划，以及向队友提很多烦人的需求（
- 负责完成寻路模块的后端实现
- 负责完成登录及个人信息的后端实现
- 负责完成AIGC后端+前端的实现
- 与队友一同完成了搜索功能的前端和后端实现
- 与队友一同完成了日记管理模块的后端实现
- 辅助刘思睿撰写报告
周晨晓

- 与队友一同完成了搜索功能的前端和后端实现
- 负责完成登录及个人主页功能的前端页面
- 负责完成寻路功能的前端页面
- 负责完成游学和日记推荐的前端页面
- 与队友一同日记管理模块的前端和后端实现
- 辅助刘思睿撰写报告
刘思睿

- 负责完成推荐模块的后端实现
- 与张泽睿一同完成了日记管理模块的后端实现
- 与队友一同完成了搜索功能的前端和后端实现
- 完成各种报告撰写
